10 Jun 2018
------------
ngModel is part of the FormsModule which can be imported from '@angular/forms';

angular.json needs to have the styles section updated with the bootstrap styling, to be able to use bootstrap.

11 Jun 2018
-------------
The index.html file in the angular project is the single page served by Angular
In the default index.html, there is a section called <app-root></app-root>. This is a default component which is served by Angular. This component is substituted with the code in the app.component.html file, which would be using the app.component.ts and other files.

In the browser, Angular injects some script files which contains the code we write. 
The first file which is executed is main.ts, where the initial module is loaded or bootstrapped --> The line is platformBrowserDynamic().bootstrapModule(AppModule).
So, the AppModule is loaded from app.module.ts, where again, it bootstraps the AppComponent --> bootstrap: [AppComponent].
Now, Angular loads the AppComponent from app.component.ts, where it sees a "selector" defined as "app-root". This is how Angular understands what <app-root> is in the index.html file, and replaces it with whatever code we have written for that to resolve to.

14 Jun 2018
___________
COMPONENTS -- Initial Primer

This is basically a markup along with a chunk of functionality

First, create a folder for all the files for the component. e.g. for a component called server, we can have a folder named 'server'.
Now, we need to create a .ts file which exports the class which should implement the functionality provided by our component
i.e. 

export class ServerComponent{
    
}

Second, declare the class is a component using an @Component decorator
@Component(
{
    selector:'app-server',
    templateUrl: './server.component.html',
    styleUrls:['./server.component.css','./server2.component.css']
})
This decorator should contain a selector, which is the html used to create this component in the markup -- in the above case <app-server></app-server>. However, these may also be of the form '[app-server]', or of the form '.app-server', in which case, they will have to be attributes of an element [e.g <div app-server></div>], or a css class of an element [e.g. <div class="app-server"></div>] to have the same effect. However, the element selector is the most used.

Third, create a file called ./server.component.html, and put the markup which needs to be displayed when the component is invoked

Fourth, add the component to the app.module.ts, in it @NgModule decorator, under the declarations section. It would require importing the component from the component name.

Finally, add a tag with the selector defined in the component to a markup file, e.g. app.component.html, like <app-server></app-server>

Now, invoking the webpage displayed, we see the markup defined in the templateUrl, in place of the selector tags.

The css defined for a component markup is fetched from the files specified in the styleUrls array. These styles are only applicable to the current component, and not any other part of the application, not even child components of this component.
This behavior can be changed by specifying a ViewEncapsulated object with value set to None in the @Component decorator, but that is mostly not the behavior we desire.

COMPONENTS -- Creating using the @angular cli
_____________________________________________
ng generate component servers 
This will create a component called 'servers' inside a 'servers' folder in our 'app' folder

This creates files for the .ts, .html, .cs and a .spec.ts file (the last file is a test script file). If we don't want the .spec.ts file use --spec false

15 Jun 2018
______________

DATA BINDING
______________

Data Output -- 
string interpolation : {{<expression, which is mostly a variable from ts>}}
Property Binding: [<some property>] = "<expression to set the value of the property>" e.g. < button [disabled]="!allowAction">Add Server</button>

Data Input --
Event Binding: (<event name>)="<typescript expression on event invocation>" e.g. <button (click)="doSomething()">Do It!</button>

if you need to use the data which is passed automatically to the event, use the $event special variable, like <button (click) = "doSemething($event)>Do It!</button>

2 way data binding --
use the syntax [(<property>)]="<value of backend property>". e.g. <input type="text" [(ngModel)]="serverData">
This will update the text in the input box, if we change the value of the "serverData" variable in the backend.

________________

ngIf Directive
________________

This is a structural directive, and is used inside an HTML element as an attribute. if the condition is true, the element is displayed, else not.
structural directives are used with an '*' in front of it. 
e.g. <p *ngIf="isValidData">{{data}}</p>

if we have an else condition, we can define an ng-template area with a marker and link the else condition of the ngIf to that marker
e.g. 
<p *ngIf="serverCreated;else noServer"> Server {{ServerName}} has been created </p>
<ng-template #noServer>
    <p>No Server has been created yet</p>
</ng-template>

More than one structural directives cannot be used on a single element
__________________________

ngStyle Directive
___________________________

This is an attribute directive, and is used like [ngStyle]="{backgroundColor:'red'}". The property backgroundColor of the element is set to red. We can set the property based on a property, by calling a method, instead of passing 'red' always. So, the code would look like
[ngStyle]="{backgroundColor:getColor()}"

we can also have a small code snippet instead of calling a funciton like
[ngStyle] = "backgroundColor:i > 4?'red':'blue'"

we can also use the javascript property for background color, in which case it would have to be in quotes. The above code would then be
[ngStyle] = "{'background-color':getColor()}" 

______________________________
ngClass
______________________________
An attribute directive which can be used to dynamically assign a class to an element, if a condition is true
It takes the form of [ngClass]="{<class_name>:<condition>}". e.g. [ngClass]="{online:serverStatus==='online'}"

______________________________
ngFor
______________________________
A built in structural directive which repeats an HTML element based on how many items are there in an array
syntax: *ngFor="let <local_variable> of <back_end_array_name>".
e.g.: <appServer *ngFor="let server of servers"></appServer>
In the above example, the <appServer> tag is repeated once for every item in the "servers" array. The local variable which can be used in the ngFor is called "server".

If we need the index of the current iteration, we can use a slightly modified syntax like below
syntax:*ngFor="let <loop_variable> of <array>; let <local_index_variable> = index"
e.g.: <p *ngFor = "let server of servers; let i = index"> {{i}} -- {{server}} </p>

More than one structural directives cannot be used on a single element

_____________________________________
ngSwitch
_____________________________________
A built in directive used to work as a switch case. It is used as below.
If we can to show different markups based on the value of a class variable backendVar the code would be

<div [ngSwitch]="backendVar">
	<p *ngSwitchCase="5">Value of backendVar is 5 </p>
	<p *ngSwitchCase="15">Value of backendVar is 15 </p>
	<p *ngSwitchDefault>Value is default </p>
</div>

__________________________________
Angular class constructor shortcut
__________________________________

We create an Angular class in using the syntax

export class newClass{
    public name:string;
    public amount:number;

    constructor(name, amount)
    {
        this.name = name;
        this.amount = amount;
    }
}

This can be shortened to 

export class newClass{
    constructor (public name, public amount){}
}

_______________________________________________
Debugging in Angular
_______________________________________________

Step 1 would be to check the browser debugger console to see if you can make sense of the error message. The line number given in the error however, doesn't map to the line causing the error in the actual code.

Step 2 would be to check the code under the "Sources" tab of the developer tools in the chrome browser. We can open the "localhost:4200" tree, and select the main.bundle.js from there, but that will have the combined source code of our app, not the files in the actual source code. However, putting a breakpoint on any line will take us to the actual source code, where Angular uses source maps to do this, but it works in development only.

Now, if you open the webpack source tree, and navigate to the src-->app folder, you will see all the files in your actual source code, and you can easily put a breakpoint in the correct file.

Step 3 - We can also use the Augury tool, which allows you to look a the components, see their properties and dependencies. It also shows details on routing.

______________________________________________
On the go type creation
______________________________________________

if we want to create a type on the fly, we need to use the below syntax

myOnTheGoType:{name:string, type:string, amount:number};

This would create a complex type for the myOnTheGoType variable, which would store individual name, type and amount values.

Also, to assign a complex data without creating a type for it, we would do this

quickVariable={name:"Yammer", type:"sportsman", amount:5}

So, on the left of the '=' sign, the above sytax is a type definition, while on the right of the '=' sign, it is a value assignment.

__________________________________________________
Passing values from outside, to a component property
__________________________________________________

The property which needs to be assigned from the outside, should be decorated with an @Input() decorator.
e.g.
@Input() element;

Now, we can have the markup of the parent compoent, assign values to this "element" property, using the normal property binding syntax, i.e. [element]="Hi There". The markup of the same component can access the values directly.

The @Input() decorator can be configured to use a different value outside the component.
e.g.
@Input('srvElement') element;

Now, the parent markup which assigns this value would need to use the syntax [srvElement]="Hi There". The previous [element]="Hi There" code will not work.

____________________________________________________
Raising events from a component, to its parent
____________________________________________________ 
We raise events from a component using the EventEmitter<> construct provided by Angular, also paring it with an @Output() decorator.
e.g. if we need to raise an event like objectAdded from our component, and the data passed is an object of type {name:string, content:string}, we need to declare this like
@Output() objectAdded = new EventEmitter<{name:string, content:string}>();

now, whenever we want to emit the event, we would write

objectAdded.emit({name:"Object Name", content: "Object Content"})

Now, the parent component would need to catch the event using code like below
e.g.
<app-child (objectAdded)="onObjectAdded()"></app-child>

Similar to the @Input decorator, we can pass a parameter to the @Output() decorator to change the name of the object passed from the outside
e.g. if in the above example, we want the parent to use the 'objAdded' event instead of the 'objectAdded' event, we can define the @Output() decorator like
@Output('objAdded') objectAdded = new EventEmitter<{.......
_________________________________________________________

Local Reference
_______________________________________________________

We can lable an HTML element in the markup using a local reference like below
<input type="text" #inputServerName>

The HTML element has now been identified as "inputServerName". This element can then be passed into Angular functions as a parameter, and properties can be extracted from these. 

e.g. <app-server (click)="onButtonClick(inputServerName)"></app-server>
These can even be used in the function like below
onButtonClick(inputFromComponent: HTMLInputElement)
{
    this.local_value = inputServerName.value;
}

The local reference is not visible in the .ts file, unless we use @ViewChild
_____________________________________
@ViewChild
_____________________________________

Just like we can get a markup element using the Local Reference, we can also bind the Local Reference to a Component property using the @ViewChild() decorator.
e.g. 
Add a Local Reference like this
<input type="text" #inputServerName>

And in the .ts file, we can declare a property like this
@ViewChild('inputServerName') inputName:ElementRef;

Now, anywhere in the code, we can access values of the input element on which we have a local reference lik
local_value = this.inputName.nativeElement.value;

We can also use this to change the value of the element in the markup, i.e. modify the DOM, 
e.g. this.inputName.nativeElement.value = "NewName"
However, we should not do so as angular has a "correct" way of doing this.

___________________________________
ng-content
___________________________________
This is a directive which allows the parent element to pass across HTML content to the child element.

Normally, anything between a child element's selectors is lost on rendering
e.g.
<app-child>My Child </app-child>

will render without the "My Child".

However, the child element can choose to output the HTML entered between it's selectors by the parent, by using the code
<ng-content></ng-content>. 
This will simply project the HTML passed from the parent to where the child's markup contains the above code.

Also, the child compoent can access any HTML element in the .ts file, if that is marked as a Local Reference with a #<identifier>
e.g.
In the parent component markup, in the content which will be projected to the child, we can set
<p #projectedParagraph>
...content which is projected
</p>

and in the child ts, we can access the HTML using
@ContentChild('projectedParagraph') contentFromParent:ElementRef

and then contentFromParent.nativeElement.<value to access>

____________________________________
Custom Attribute Directives
____________________________________
Custom Directives are just typescript  classes which achieve functionality on an HTML element on which it is applied.

By convention, we create a file of the form <some_name>.directive.ts to host the directivecode
e.g.
basic-highlight.directive.ts

The filename, by convention should be <Directive Name>Directive
e.g.
export class BasicHighlightDirective{
}

On top of a directive class, we should declare an @Directive() decorator, specifying the 'selector' used for the directive. This decorator should be imported from '@angular/cli'

e.g
@Directive({selector:'[appBasicHighlightDirective]'})
export class BasicHighlightDirective{
	
}
Note: Unlike a Component, a Directive doesn't take a template attribute.

The element on which the directive is placed can be accessed in the constructor like
constructor(private elementRef:ElementRef){}

The onInit() function would be a very good place to manipulate the attributes of the element
onInit()
{
	this.elementRef.nativeElement.style.backgroundColor='blue';
}

Finally, the directive's class needs to be included in app.module.ts inside the @NgModule declarations section, and it can be used on elements like

<p appBasicHighlightDirective>Style Me</p>

In the above case, the "Style Me" string will have a background color of blue.

However, we should ideally not be using the elementRef object to directly style elements, as Angular can work in environments which don't have a DOM. So, we should use a class called Renderer2, to manipulate the element. In this case, our constructor and ngOnInit functions would look like below
e.g.
constructor(private elRef:ElementRef, private renderer:Renderer2){}

ngOnInit()
{
	this.renderer.setStyle(this.elRef,'background-color','blue');
	this.renderer.setStyle(this.elRef,'color','white');
}

We can also react to events on elements on which the directives can be applied, using the @HostListener directive in the form
@HostListener('<event to react to>') <function_name>(){
...code to execute on the occurence of the event on the element
}

e.g., if we want to change the color of an element on mouse enter, we can write the following code
@HostListener('mouseenter') myMouseEnterFunction(eventData:Event)
{
	this.renderer.setStyle(this.elRef, 'color', 'red');
}

Apart from using the renderer, there is also one more way in which we can change element properties, and this is using the @HostBinding() directive of the form
@HostBinding('<property to change>') <mapped_variable>:<variable_type>;

e.g. if we want to access the background color of a variable, then we can use the following code
@HostBinding('backgroundColor') backgroundColor:string;
and in a function where we need to change the background color, we can set
backgroundColor = 'blue';

note the camel case, which is the way we need to pass properties into the @HostBinding() directive, without the '-'.

________________________________
Passing parameters to Directives
________________________________

In order to pass parameters to Directives, we can use the @Input() decorator, just like in Components. e.g., if we have an attribute directive called "[SampleDirective]" which requires the value of a "directive_var" to be set, we need to define a variable in the directive class like,

@Input() directive_var:string = 'some_default_value';

The 'some_default_value' is the default value, if the user doesn't set the value of "directive_var" in the markup
Now, in the html which uses this directive, we can set the value of the "directive_var" like below

<p SampleDirective [directive_var]="'some other value'">Blah! Blah! Blah!</p>

Angular figures out ("somehow") that the [directive_var] is not a property of the <p> html element, and that it actually belongs to the "SampleDirective" and then processes it accordingly.

If we use the directive selector as the name of an internal directive variable, then, we can use a shorthand to use the directive
e.g.
In the directive class, if we define the input variable like
@Input('SampleDirective') directive_var:string = 'some_default_value';

Then in the markup, we can use the shorthand like
<p [SampleDirective] = "'some other value'">Blah! Blah! Blah!</p>

_________________________________
Custom Structural Directives
_________________________________

When we create structural directives, the selector is the same as an attribute directive. So if we have a structural directive which we want to refer to as appStructuralDirective, we need to define the selector as
@Directive({selector:'[appStructuralDirective]'})

However, we need to define an Input property of the directive class with the same name as the selector. We also need to use only the set property of the @Input() decorator like
@Input('appStructuralDirective') set mainDirectiveVariable(value:boolean){
	
}

If we are changing the DOM, we need 2 variables -- 1, the template which was passed, and second, the view container onto which to display the html which is emitted by the directive.

so, we need to pass the variables into the constructor as
constructor(private templateRef:TemplateRef<any>, private viewContainerRef:ViewContainerRef){
}

we can now use these variables in the set method defined earlier like
@Input('appStructuralDirective') set mainDirectiveVariable(value:string){
	if (value) {
		viewContainerRef.createEmbeddedView(templateRef);
	}
	else
	{
		viewContainerRef.clear();
	}
}

The above is the code for a directive like ngIf
_______________________________________________

Services
_______________________________________________

Services are classes in Angular which provide functionality, which can be centralized to the whole Angular project. The difference between a normal class and an Angular Service is that a service can be injected into components by Angular's infrastructure.

Given below are the steps to create a service.

Step 1: Create a class which provides the service, e.g.

export class DummyService(){
	do_something_valuable(input:string){
		....
	}
}

Now, in the component where we want to utilize the service, we add the service to a providers array in the @Component() decorator, e.g.

@Component({
	selector:'app-my-component',
	styleUris:['./styles.css],
	providers:[DummyService]
})

and in the class constructor we include a variable of the "Service" type, as a parameter like
constructor(private dummyService:DummyService){}

Finally, in the component method where we plan to use the service, we can just invoke it like a local class variable which has been initialized.
e.g.

this.dummyService.do_something_valuable("Hello");

______________________________________
Service Injection Hierarchy
_____________________________________
If a service is injected into appModule, the same instance of the Service it is available throughout the application.
If a service is injected into the App Component, the same instance of the Service is available for all the Components of the application.
If a service is injected into the Component, the same instance of the service is available for the Component and all the child components.
If a service is injected at any level, it overrides all service instances above it.

____________________________
@Injectable()
_____________________________
In order to inject a service into another service, we need to 
declare the service which is used inside the other service in the app.module.ts file, in the @NgModel() directive, inside its providers array.

Then, in the service we want to use the directive, use the @Injectable() directive above the class declaration.

Finally, we also need to "inject" the service into constructor of the class. 

_______________________________
Events inside services
_______________________________

We can have events inside a service, emitted and subscribed to by any component that uses the service.

e.g. if we have an AccountsService where we plan to emit an event of type string, we would declare it in the class like
StatusUpdate = new EventEmitter<string>();

Now, in any component where we have injected the service, we can emit or subscribe to the event.

The event can be emitted in a component subscribing to the event like

this.accountService.StatusUpdate.emit("Dummy Status Update");

And in another Component where we have injected the service, we can subscribe to it like

this.accountsService.StatusUpdate.subscribe((status:string)=>{do_something....});

________________________________________
Routing
________________________________________
In order to implement routing in Angular, wherein you can give the impression of different pages loading up when the URL changes, you need to do the following.

1. Set up a routing table of the form inside the app.modules.ts file

const appRoutes:Routes=[ 
			{path:'', component:HomeComponent},
			{path:'users',component:UsersComponent}
		];

Each of the route element contains a path string, which is the sub-url to navigate to to display the corresponding component.

Note: Both Routes and the RouterModule need to be imported from @angular/router.
Note: The path component should be listed without the separating '/' character

2. Register the appRoutes array inside the "imports" section of the @NgModule() directive like below. The "RouterModule.forRoot(appRoutes)" is the line added to the imports array to register the routes

imports:[
	BrowserModule,
	FormsModule,
	HttpModule,
	RouterModule.forRoot(appRoutes)	
]

3. Set up an area where to display the component when a route's path conditions are satisfied, using the <router-outlet> directive like

<p>
	<router-outlet></router-outlet>
</p>
______________________________________________________________
routerLink
______________________________________________________________

After setting up routes, while we can manually navigate to a page using href="". However, it causes the entire page to refresh, which may cause us to lose state. To prevent this, we use routerLink

e.g <a routerLink="/">Home</a>
would navigate to the home page and
<a routerLink="/servers">Servers</a>
would navigate to the "/servers" path which is set up in the routes in app.module.ts

We can also bind to routerLink using property binding, and pass an arry with multiple values to it like

<a [routerLink]="['users','param1', 'param2']"

this will allow us to navigate to a link like /users/param1/param2

Note: if we don't use the leading '/' character, the path is considered a relative path. e.g if we say
<a routerLink="servers">Servers</a>
it would go to <current path>/Servers
We can also use "./" in front of the path for a relative path and "../" in front of the path to go back a level, just like folder navigation in windows/linux. However, it doesn't go back 1 segment between 2 '/'s exactly -- it goes back to before the currently loaded segment, which may be contributing more than one '/' to the path.
________________________________________________________________________
routerLinkActive
______________________________________________________________

This is an Angular directive which allows us to attach a CSS class to an element if the link on which the page sits matches the path specified by the routerLink directive on the same element. This helps in giving a visual indication to the user that the current element is the one which is active.

e.g.
<li role="presentation" routerLinkActive = "active">
	<a routerLink="/">Home</a>
</li>
This attaches the "active" class to the element if the current path matches the routerLink path specified in the component, or the child component

However, this class is attached any time the path matches, and in case of root paths, will always be active. In this case, we want the class to be attached only if the path matches exactly. So, we make use of another directive called the routerLinkActiveOptions like
<li role="presentatation" routerLinkActive="active" [routerLinkActiveOptions]='{exact: true}'>
	<a routerLink="/">Home</a>
</li>
Note: We need to use property binding syntax for this, as we pass an object, whose "exact" property is set to "true".
______________________________________________
programmatically navigating to a router link
______________________________________________

If we need to programmatically navigate to a router link, we first need to inject the "Router" service in the constructor of the class we plan to use programmatical routing, like

constructor (private router:Router){}

where "Router" needs to be imported from '@angular/router'.

Now, whenever we need to import the router link, we call 

this.router.navigate(['users']);

The array passed to the above function is the same as the array passed to the routerLink directive
However, the path is treated as an absolute path if no additional parameters are sent to the function. However, can set the relative path while navigating programmatically by passing it into the second parameter of the navigate function like
this.router.navigate(['users'],{relativeTo:this.activatedRoute});

where activatedRoute is of type ActivatedRoute, injected into the constructor like
constructor(private activatedRoute:ActivatedRoute, private router:Router),
Note: Both ActivatedRoute and Router are imported from '@angular/router'.

____________________________________________
Passing parameters to routes
____________________________________________

In order to pass a dynamic route parameter, the route needs to be added like below into the app.module.ts file
appRoutes:Routes[]=[{path:'/users/:id/:name', component:UserComponent}];

Now, we can navigate to the url using http://root_path/users/1/Somebody

And in the component which handles the route, we extract the id and name as below

this.local_id = this.activatedRoute.snapshot.params['id']; and
this.local_name = this.activatedRoute.snapshot.params['name'];

where activatedRoute is injected into the constructor, and is of the form

constructor(private activatedRoute:ActivatedRoute){}

and ActivatedRoute is imported from '@angular/Router'

However, if the parameters on the route link change from inside the page, Angular doesn't refresh the element values automatically. So, in order to track the changes, we need to subscribe, which we do as below

activatedRoute.params.subscribe(
(params:Params)=>{
	this.local_id=params['id'];
	this.local_name=params['name'];
});

Note: The subscription is automatically destroyed when we navigate away from the component

______________________________________________
Passing Query parameters and fragments to routes
______________________________________________

Query parameters are arguments passed to a link like ?edit=true&fire=false

In order to pass query parameters, in the markup, we use properties of the routerLink directive
e.g.
To navigate to the root/servers/5/edit/?allowEdit=true&fire=false, we would have a markup like

<a [routerLink]="['servers',server.id,edit]" [queryParams]="{edit:'true', fire:'false'}">Click Here </a>

The parameters passed to queryParams are of the form of key value pairs

If we need to add a fragment #loading also to the url, we would be using the fragment property of the routerLink directive like
<a [routerLink]="['servers',server.id,'edit']" [queryParams]='[edit:"true", fire:"false"]' fragment="loading">

If we need to add query params and fragments programatically, we would do that using the navigate property of the router service, which we inject into the constructor, like

this.router.navigate(['servers',this.selectedServer.id, 'edit'], {queryParams:{edit:'true', fire:'false'}, fragment:'loading'});

That is, we use the second parameters, which is the navigationExtras object, which itself is composed of objects like queryParams and fragment. queryParam is a key value pair.

__________________________________________________________
Retreiving Query Params and fragments from the URL
__________________________________________________________

This is similar to retreiving params using the activatedRoute injected service.
To retreive query params, we would do the following
let allowEdit = this.activatedRoute.snapshot.queryParams['edit'];
let fire = this.activatedRoute.snapshot.queryParams['fire'];

And similarly, we can retreive the fragment using

let urlFragment = this.activatedRoute.snapshot.fragment;

Again, similar to params, we can subscribe to events for queryParams and fragment, to react to changes

e.g.

this.activatedRoute.queryParams.subscribe(<your code here>);
this.activatedRoute.fragement.subscribe(<your code here>);

_______________________________________________________________
Nested Routes
_______________________________________________________________

When we want to have one component inside another, but also have the nested component based on the url route, we use nested routes

e.g.

Main Component Page
Main Component item|
Main Component item|Another component Page
Main Component item|

To do this, in the appRoutes inside the app.module.ts, we update the route to the main component to include a "children" property, which is an array.

e.g.

appRoutes:Routes[]=[{path:"servers", component:ServersComponent, children:
	[path:":id", component:ServerComponent],
	[path:":id/edit", component:ServerEditComponent]
}];

Now, the route till <root_path>/servers will load the ServersComponent, and the <root_path>/servers/:id or the the <root_path>/servers/:id/edit routes would load the ServerComponent or the ServerEditComponent inside the <router-outlet></router-outlet> placeholder in the ServersComponent markup.

e.g.
In the Servers.Component.html
<p> All Servers<p>
<div *ngFor="let server of servers">
	{{server.id}}:{{server.name}}
</div>
<router-outlet></router-outlet>

Note: the ServersComponent itself would be loaded in the <router-outlet></router-outlet> placeholder of its parent component, which could be the AppComponent itself.
___________________________________
Preserving Query Params on routing
___________________________________

On navigating to a new route, older query parameters are dropped. To prevent this, we have options to merge the older query parameters with newer ones we just add, or to preserve the older ones which were there. The options are available under the queryHandling property of the navigationExtras object passed to the navigate method of the Router service like

this.router.navigate(['edit'], {relativeTo:this.activatedRoute, queryParamsHandling:'preserve'});

If we want to merge the passed query params with our query params, we would use 'merge' instead of 'preserve'

______________________________________________
redirecting routes and catching all routes
______________________________________________

If our appRoutes:Routes[] in our app.module.ts has a route with the path '**', it will catch all routes
e.g.

{path:'**', component: PathNotFoundComponent}

However, this should be the last entry of the appRoutes as otherwise, all routes would map to this route

A better way would be to redirect all unknown pages to a "not-found" route which displays the PathNotFound component. We do this like below
e.g.

appRoutes:Routes[]=[...
{path:'not-found', component:PathNotFoundComponent},
{path:'**', redirectTo:'not-found'}]

In this case, any unknown route would get redirected to the 'not-found' path, and then the PathNotFoundComponent would be displayed.

Note: In case we are redirecting an empty path, i. e. path:'' to another route, we need to use the pathMatch:'full', so that the path doesn't become recursive, as every route matches the '' route. The default value of pathMatch:'prefix'
_______________________________________________________
Route Guards
_______________________________________________________
We can guard a route, that is control a route from being navigated to, by creating a class which implements the CanActivate Interface. Only if the CanActivate method of the class returns true, will the routing go ahead.

So, if we want to restrict the <root>/servers route, include a canActivate element in the path, with the class which guards the route

e.g.
in the appRoutes:Routes[
...
{path:"servers", canActivate: [ServerGuard], component: ServersComponent},
...
};

The ServerGuard class would be a service, implemented like

export class ServerGuard implements CanActivate{
	CanActivate(activatedRouteSnapshot:ActivatedRouteSnapshot, routerStateSnapshot:RouterStateSnapshot):
	Observable<boolean>|Promise<boolean>|boolean
	{
		if (this.isAuthenticated)
		{
			return true;
		}
		else
		{
			//we can navigate to some other place if required like router.navigate(['/']);
			return false;
		}
	}
}

Note: Objects of type ActivatedRouteSnapshot and RouterStateSnapshot are provided automatically by Angular, to the CanActivate method.

Note: The CanActivate element in the route guards the route, and the child routes of the route, if any.

Note: We can prevent access to all child routes of a route, by creating a class implementing the CanActivateChild method, similar to the CanActivate method. In this case, in the parent route, include a "CanActivateChild:[<guard-class-name>]". The same class can implement both the CanActivate and the CanActivateChild interface.

__________________________________
Route Leaving Guards
__________________________________
Similar to route guards, which prevent navigating to a route, we can implmenent guards which prevent a user from leaving a route. This is mostly used when the user forgets to save something before navigating.

However, creating such a guard is more involved. We need a class which implements a CanDeactivate interface, which itself is a generic interface. This interface, takes as a parameter, another interface, which declares the function which we would be using as the "route leaving guard". This function, is implemented in the component displayed by the route, where we want to keep the user at.

e.g.

First implement the interface declaring the route Deactivate guard

export interface IRouteDeactivate{
	canLeaveRoute(): Observable(boolean)|Promise(boolean)|boolean;
}

Then implement a service which implements the CanDeactivate generic interface with IRouteDeactivate as the parameter

export class RouteDeactivate implements CanDeactivate<IRouteDeactivate>{
	canDeactivate(component:IRouteDeactivate,
			activatedRouteSnapshot:ActivatedRouteSnapshot,
			currentRoute:RouteStateSnapshot,
			nextRoute:RouteStateSnapshot){
		component.canLeaveRoute();		
	}
}

In the component class which the route would be using, implement the IRouteDeactivate interface which was created earlier.

export class ServersComponent implements OnInit, IRouteDeactivate{

...
	canLeaveRoute()
	{
		if (<condition>)
		{
			confirm("Lose changes?");
		}
		else
		{
			return true;
		}
	}
...
}

declare the RouteDeactivate component as a service by including it in the providers[] array inside @NgModule() in app.module.ts

Finally, to the component route in appRoutes which needs to be guarded from leaving, add a CanDeactivate:[] element with the RouteDeactivate Class

appRoutes:Routes[]=[
...
	{path:"servers", component: ServersComponent, canDeactivate:[RouteDeactivate]}
...
];
__________________________________________________
Observables in Angular 6
__________________________________________________
Since Angular 6, the way to use observables has changed. The old way to use observables can be preserved using the rxjp-compat module from npm, using 
npm install --save rxjs-compat

This may be already installed for you though -- check in your package.json file

____________________________________
Using the interval method to create an Observable
__________________________________________________

The Rxjs package has a number of methods to create observables for us. One of these methods is the interval method.

First, we need to 
import { Observables } from 'rxjs';

then, to create an observable using the interval method, we

//This interval emits a value every 1s
const myIntervalObservable = interval(1000);

the subscribe method to an interval takes 3 parameters, all of which are functions.
The first parameter is the callback function which is called when the event subscribed to occurs, the second function is the callback invoked when the observable sends out an error event, and the third is the function to call when the "Complete" event for the observable occurs.

In the case of the interval Observable, it doesn't error out (normally), and it never completes, so we don't need to subscribe to these events.

So, here is the subscription code

e.g
myIntervalObservable.subscribe( (value:number) => {console.log("Got Value:" + value;});

Note: The observable continues to be subscribed to, until we unscribe. Most of the Angular Observables are auto-unsubscribed to, when the component goes out of scope, but for custom Observables like the above, we need to specifically unscribe.

e.g

const myObservableSubscription:Subscription;

myNumbersObservable = myObservableSubscription.interval(1000);
myObservableSubscription = myNumbersObservable.subscribe( () => {//do something} );

and finally, maybe in the OnDestroy method, call
myObservableSubscription.unscribe();

____________________________________
Creating an observable from scratch
____________________________________

The code for this would be something like

e.g.
const myObservable = Observable.create((observer:Observer<type>)=>{The loop which the Observable keeps running});

In the loop is what the observable runs, in order to retun and event of the type subscribed to, we need to write
e.g.
observer.next(<type>);

and in order to return an error, we write
e.g.
observer.error(<type>);

and finally, in order to complete the Observable, we would write
e.g.
observer.complete();
The complete event doesn't take a parameter.

const myObservableSubscription:Subscription;


And we would subscribe to it like

myObservableSubscription = myObservable.subscribe(
(value:<type>) => {/*What to do when the subscribed event occurs*/},
(value:<type>) => {/*What to do when an error event occurs*/},
() => {/*What to do when the subscribtion completes}
);

When we are done with using the observable, we should unscribe, otherwise the subscription continues forever, possibly causing memory leaks

myObservableSubscription.unsubscribe();
Note: If once the Observable sends out a complete event, any other normal event sent by the Obserable doesn't register.

______________
Rxjs Subject
______________

A class provided by Rxjs which allows the user to set up both the observable part, and the subscription part from one interface. It can be used to communicate between components, instead of using the eventEmitter.

setting up a subject
e.g.
mySubject:Subject = new Subject();

and in order to send an event
e.g.
mySubject.next(id: number);

and for someone to subscribe to this
e.g.
mySubject.subscribe((id:number) => {});

If the subject is exposed as a service, we can use it to synchronize components.

_______________
Rxjs Operators
_______________

Operators convert the value returned from one Observable to another. To the subscriber, it seems like the original Observable is returning the new values.

With Angular 6, the way to use operators has changed. Earlier, we could use the operators in a chain, like 
e.g
myObserver = Observable.create((observer: Observer<number>) => { /*something to do*/}).operator1((data:number) => {}).operator2((data: number) => {});

The final output for the subscriber would be what is returned by operator 2.

Now, with Angular 6, instead of chaining, we have a pipe function, which takes infinite arguments, and each argument is an operator

e.g.

myObserver = Observer.create( (myObserver: Observer<data: number>) => {/*Do something*/} ).pipe(
	map( (data:number) => {return data * 2}), switch ( (data: number) => {/*do something*/})
);

The final output for the subscriber would be what is returned by the switch operator.

__________________________
Template forms in Angular
__________________________

There are 2 approaches to creating forms in Angular. Template driven and reactive.

In the Template driven approach, the form template is created in HTML and we use some markers to indicate to Angular, the various input fields in the form.

We do this by adding "ngModel" to an input element, and also giving a name to the element.
e.g.
<label for="name_element">Your Name:</label>
<input type="text" id="name_element" ngModel name="input_name">

In the above code, we are setting up the input element to be called "input_name" in Angular.

In order to submit the form, we need to have a button with type = "submit". However, for form submit to be handled by Angular, our form should not have an "action" or a "method" attribute. Instead, the form element should handle the ngSubmit event, and the handler can use a templateRef of the form passed as input. There is a change to the normal templateRef elements, wherein the templateRef is set equal to "ngForm", in order to allow angular to acces the form data.

e.g.
<form (ngSubmit)="onSubmit(f)" #f="ngForm">
.....
</form>

We can also use the ViewChild() method to gain access to the form.
e.g.

@ViewChild('f') inputForm:NgForm;

We can then use individual properties of the inputForm class variable.
____________________________________
Validating input in Template forms
____________________________________

In order to impose validation, we can use the HTML keywords like "required" to enforce that an input has value, and "email" to enforce email like format. 
Angular checks these on input elements and adds classes like ng-valid and ng-invalid, which can be used to style the controls to show errors.

In the .css file, we can add styling targeting all input elements, which have been touched like below
e.g.
input.ng-invalid.ng-touched{
	border: 1px solid red;
}

We can also use a reference to an element using templateRef to show helpful error hints. In the example below, #email is the reference which can be used by the *ngIf condition
e.g.

<label for="email">Email:</label>
<input id="email" ngModel name="email" #email="ngModel" required email>
<div *ngIf="email.valid && email.touched">
	<p>Please enter a valid email!</p>
</div>
_________________________________________
setting default values for input controls
_________________________________________

if we use property binding to bind the ngModel directive to a value, that sets the default value for a form element.

e.g.
<input type="text" [ngModel]="'defaultText'">
will set defaultText as the default value in the textbox

Instead of a direct value, we can also use a variable in the .ts file

____________________________________________
Reacting instantly to value changes in forms
____________________________________________

This can be done by using 2 way property binding on the ngModel directive on the control

e.g.

<div class="form-group">
	<textarea [(ngModel)]="answer" name="enteredAnswer"></textarea>
	<p>You entered:{{answer}}</p>
</div>

You will have to declare a property called answer in the .ts file.
Now, any change made in the text in the text box is automatically shown after the "You entered:" of the <p> element

______________
ngModelGroup
______________
When we want to group multiple controls into one, we can use an encompassing div adorned with the ngModelGroup directive. This ngModelGroup needs to be given a unique name in the form.

e.g
<div ngModelGroup="userData">

We can then use expressions like
e.g.
userData.valid and userData.touched, similar to what we do with individual controls



	...
</div>

__________________________
Working with Radio Buttons
__________________________
Working with radio buttons on Forms is not too different. Here is an example. Let's say we have list of strings in the .ts backend file, which we want to create radio buttons of
e.g
genders=['male', 'female'];

In the front-end HTML file, we can create a radio button using
e.g.
<div class="radio" *ngFor="let gender of genders">
	<label>
		<input type="radio" ngModel name="gender" required>
		{{gender}}
	</label>
</div>

In this case, the same name property is applied to each individual radio button.
Also, we can set the required property on every radio button to enforce that a value be selected for the control

________________________
setValue and patchValue
________________________
We can set the data on a form from the backend using the setValue and patchValue function.

Using setValue, we can set the value of all the controls on the form in one go. If the NgForm object is referenced as an inputForm in the back-end, the code will be

e.g.

this.inputForm.setValue(
	{
		userData:{
			inputName:'someone',
			inputEmail:'somebody@somewhere'
		}
		defaultQuestion:'howdy?'
	}
);

Note: We need to pass the entire form as a javascript object to the setValue method
Note: in case of form elements encompassed by the NgModelGroup directive, the entry should be a javascript object with the name passed to the NgModelGroup directive, and this javascript object should have entries for each of its elements. The identifiers for elements would be the name of the element.

We can set an individual element's value on a form object using the patchValue method. It is used as below
e.g.

this.inputForm.form.patchValue(
	{userData:{
			inputName:'Nobody'
		}
	}
);

_____________________

Retreiving Form Data
_____________________

In the back-end, we can retreive the data submitted by treating the submitted form as a javascript object
e.g.
inputForm.value.inputName;

If an element is wrapped inside and ngModelGroup, lets say called "userData", it will be accessed like
e.g.
inputForm.value.userData.inputName;

_____________________
Resetting Form Data
_____________________

If the form is known as inputForm in the back-end, we can reset the form like

e.g.
this.inputForm.reset();

This resets to form to its initial untouched state.

The reset function can also take a javascript object to set the input values of the form, just like the setValue() function.
_______________
Reactive Forms
_______________

These are the similar to template driven forms, given then we use HTML to create the form input components. However, it is different in the way that we don't use a reference to the form from the HTML front-end. 

We create a form in the back-end, and associate input controls of the html to it.

That way, we can directly access the values of the form from the object in the back-end, rather than loading it from the @ViewChild('form-name-in-html') reference to the front-end form.

Declaring a form using the reactive approach.

In the back-end .ts file, declare a form object like

e.g.
signupForm:FormGroup;

We would need to initialize this form, passing in all the controls we need from the form, as a JavaScript object.
Each element of the JavaScript object is of the form
<form control name>: new FormControl(<default_value>,<validators>,<async. validators>).
We can pass null to the constructor if we don't want to set a default value.

e.g.
signupForm = new FormGroup({
	username:new FormControl(null),
	email: new FormControl('a@b.com')
});

Note: we may want to say 'username':new FormControl(null) if we don't want the value of username to be lost during minification

Now, in the front-end form, we need to associate the form element to the back-end form object. We do it like this.

e.g.
<form [formGroup]="signupForm">

</form>

Also, we need to associate all input form controls to the FormControl objects in the back-end form.

e.g.

<label for="user">Enter Username</label>
<input type="text" formControlName="username" id="user">

This will link the input text object to the "username" FormControl object, of the inputForm FormGroup in the back-end.
_____________________________________________________________________
Adding Validators to controls when using the reactive forms approach
_____________________________________________________________________

In the template driven approach, we used HTML validators in the front end like email and required to set the validity requirements of each field.

In the reactive approach however, we do this in the back-end, by using the validators array passed to the FormControl object, like

e.g.
username: new FormControl(null, Validators.required),
email:	new FormControl(null, [Validators.required, Validators.email]),
...

_________________________________________________________________________
notifying users of validation errors in the front-end for Reactive forms
_________________________________________________________________________
classes like ng-valid and ng-touched are applied to front-end form controls the same way as in the template driven approach.

So in the CSS, something like this will still work
e.g.
input.ng-invalid.ng-touched{
	border: 1px solid red;
}

If we want to have a text informing the user that there was a validation error, we would need to take slightly different approach that with the Template driven forms. 

If our form is named signupForm in the back-end, and the control's name in the form is username, we need to do the following for showing a text on a validation error

e.g.

<span *ngIf="!signupForm.get('username').valid && signupForm.get('username').touched">
	Please enter a valid username!
</span>

___________________
Nesting FormGroups
___________________

We can nest FormGroups to create something similar to ngModelGroup which is used in the template driven approach.

To do this, when declaring the form, we use an inner form group.

e.g.
signupForm = new FormGroup({
	userData: new FormGroup({
		name: new FormControl(null, Validators.required),
		email: new FormControl(null, [Validators.required, Validators.email])
	}),
	gender: new FormControl('male',Validators.required),
});

Now, to get to the name element in the userData FormGroup, we use the code
e.g.
signupForm.userData.email

Finally, in the front end, we need to nest our name and email form controls under something like
e.g.

<div formGroupName="userData">
	<label>Enter Your Name:</label>
	<input formControlName="name">
	<label>Enter email: </label>
	<input formControlName="email">
</div>
_________
FormArray
__________

In order to store a group of controls, the count of which may vary we can use a FormArray. 
Similar to a from group, it holds a group of controls. The controls however are stored as an array. However, unlike a FormGroup, these controls are not named, but are accessed by the index of the control inside the array.

So, if we want to store a list of hobbies for the user as a FormArray, we can include into the form object, something like

e.g.
this.signupForm = new FormGroup(
	'name': new FormControl(null),
	'email': new FormControl(null),
	'hobbies': new FormArray([])
	);

We can also initialize some FormControls in that, by passing them into the array -- like new FormArray([new FormControl(null)])

Now, in order to push data into the FormArray, the code would be 
e.g.
(<FormArray>this.signupForm.get('hobbies')).push(new FormControl(null,[Validators.required]))
Note: This is one of the few cases where we need use casting

In the front end, we can have a button invoking a function to dynamically add items to the form array like below
e.g.
onAddHobby()
{
	(<FormArray>this.signupForm.get('hobbies')).push(new FormControl())
}

Also, in the front end, we can cycle through the Form array like below, 
e.g.
<div formArrayName="hobbies">
	<div *ngFor="let control of signupForm.get('hobbies').controls; let i = index">
		<input type="text" [formControlName]="i">
	</div>
</div>

