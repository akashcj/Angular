10 Jun 2018
------------
ngModel is part of the FormsModule which can be imported from '@angular/forms';

angular.json needs to have the styles section updated with the bootstrap styling

11 Jun 2018
-------------
The index.html file in the angular project is the single page served by Angular
In the default index.html, there is a section called <app-root></app-root>. This is a default component which is served by Angular. This component is substituted with the code in the app.component.html file, which would be using the app.component.ts and other files.

In the browser, Angular injects some script files which contains the code we write. 
The first file which is executed is main.ts, where the initial module is loaded or bootstrapped --> The line is platformBrowserDynamic().bootstrapModule(AppModule).
So, the AppModule is loaded from app.module.ts, where again, it bootstraps the AppComponent --> bootstrap: [AppComponent].
Now, Angular loads the AppComponent from app.component.ts, where it sees a "selector" defined as "app-root". This is how Angular understands what <app-root> is in the index.html file, and replaces it with whatever code we have written for that to resolve to.

14 Jun 2018
___________
COMPONENTS -- Initial Primer

This is basically a markup along with a chunk of functionality

First, create a folder for all the files for the component. e.g. for a component called server, we can have a folder named 'server'.
Now, we need to create a .ts file which exports the class which should implement the functionality provided by our component
i.e. 

export class ServerComponent{
    
}

Second, declare the class is a component using an @Component decorator
@Component(
{
    selector:'app-server',
    templateUrl: './server.component.html',
    styleUrls:['./server.component.css','./server2.component.css']
})
This decorator should contain a selector, which is the html used to create this component in the markup -- in the above case <app-server></app-server>. However, these may also be of the form '[app-server]', or of the form '.app-server', in which case, they will have to be attributes of an element [e.g <div app-server></div>], or a css class of an element [e.g. <div class="app-server"></div>] to have the same effect. However, the element selector is the most used.

Third, create a file called ./server.component.html, and put the markup which needs to be displayed when the component is invoked

Fourth, add the component to the app.module.ts, in it @NgModule decorator, under the declarations section. It would require importing the component from the component name.

Finally, add a tag with the selector defined in the component to a markup file, e.g. app.component.html, like <app-server></app-server>

Now, invoking the webpage displayed, we see the markup defined in the templateUrl, in place of the selector tags.

The css defined for a component markup is fetched from the files specified in the styleUrls array. These styles are only applicable to the current component, and not any other part of the application, not even child components of this component.
This behavior can be changed by specifying a ViewEncapsulated object with value set to None in the @Component decorator, but that is mostly not the behavior we desire.

COMPONENTS -- Creating using the @angular cli
_____________________________________________
ng generate component servers 
This will create a component called 'servers' inside a 'servers' folder in our 'app' folder

This creates files for the .ts, .html, .cs and a .spec.ts file (the last file is a test script file). If we don't want the .spec.ts file use --spec false

15 Jun 2018
______________

DATA BINDING
______________

Data Output -- 
string interpolation : {{<expression, which is mostly a variable from ts>}}
Property Binding: [<some property>] = "<expression to set the value of the property>" e.g. < button [disabled]="!allowAction">Add Server</button>

Data Input --
Event Binding: (<event name>)="<typescript expression on event invocation>" e.g. <button (click)="doSomething()">Do It!</button>

if you need to use the data which is passed automatically to the event, use the $event special variable, like <button (click) = "doSemething($event)>Do It!</button>

2 way data binding --
use the syntax [(<property>)]="<value of backend property>". e.g. <input type="text" [(ngModel)]="serverData">
This will update the text in the input box, if we change the value of the "serverData" variable in the backend.

________________

ngIf Directive
________________

This is a structural directive, and is used inside an HTML element as an attribute. if the condition is true, the element is displayed, else not.
structural directives are used with an '*' in front of it. 
e.g. <p *ngIf="isValidData">{{data}}</p>

if we have an else condition, we can define an ng-template area with a marker and link the else condition of the ngIf to that marker
e.g. 
<p *ngIf="serverCreated;else noServer> Server {{ServerName}} has been created </p>
<ng-template #noServer>
    <p>No Server has been created yet</p>
</ng-template>

__________________________

ngStyle Directive
___________________________

This is an attribute directive, and is used like [ngStyle]="{backgroundColor:'red'}". The property backgroundColor of the element is set to red. We can set the property based on a property, by calling a method, instead of passing 'red' always. So, the code would look like
[ngStyle]="{backgroundColor:getColor()}"

we can also have a small code snippet instead of calling a funciton like
[ngStyle] = "backgroundColor:i > 4?'red':'blue'"

we can also use the javascript property for background color, in which case it would have to be in quotes. The above code would then be
[ngStyle] = "{'background-color':getColor()}" 

______________________________
ngClass
______________________________
An attribute directive which can be used to dynamically assign a class to an element, if a condition is true
It takes the form of [ngClass]="{<class_name>:<condition>}". e.g. [ngClass]="{online:serverStatus==='online'}"

______________________________
ngFor
______________________________
A built in directive which repeats an HTML element based on how many items are there in an array
syntax: *ngFor="let <local_variable> of <back_end_array_name>".
e.g.: <appServer *ngFor="let server of servers"></appServer>
In the above example, the <appServer> tag is repeated once for every item in the "servers" array. The local variable which can be used in the ngFor is called "server".

If we need the index of the current iteration, we can use a slightly modified syntax like below
syntax:*ngFor="let <loop_variable> of <array>; let <local_index_variable> = index"
e.g.: <p *ngFor = "let server of servers; let i = index"> {{i}} -- {{server}} </p>

__________________________________
Angular class constructor shortcut
__________________________________

We create an Angular class in using the syntax

export class newClass{
    public name:string;
    public amount:number;

    constructor(name, amount)
    {
        this.name = name;
        this.amount = amount;
    }
}

This can be shortened to 

export class newClass{
    constructor (public name, public amount){}
}

_______________________________________________
Debugging in Angular
_______________________________________________

Step 1 would be to check the browser debugger console to see if you can make sense of the error message. The line number given in the error however, doesn't map to the line causing the error in the actual code.

Step 2 would be to check the code under the "Sources" tab of the developer tools in the chrome browser. We can open the "localhost:4200" tree, and select the main.bundle.js from there, but that will have the combined source code of our app, not the files in the actual source code. However, putting a breakpoint on any line will take us to the actual source code, where Angular uses source maps to do this, but it works in development only.

Now, if you open the webpack source tree, and navigate to the src-->app folder, you will see all the files in your actual source code, and you can easily put a breakpoint in the correct file.

Step 3 - We can also use the Augury tool, which allows you to look a the components, see their properties and dependencies. It also shows details on routing.

______________________________________________
On the go type creation
______________________________________________

if we want to create a type on the fly, we need to use the below syntax

myOnTheGoType:{name:string, type:string, amount:number};

This would create a complex type for the myOnTheGoType variable, which would store individual name, type and amount values.

Also, to assign a complex data without creating a type for it, we would do this

quickVariable={name:"Yammer", type:"sportsman", amount:5}

So, on the left of the '=' sign, the above sytax is a type definition, while on the right of the '=' sign, it is a value assignment.

__________________________________________________
Passing values from outside, to a component property
__________________________________________________

The property which needs to be assigned from the outside, should be decorated with an @Input() decorator.
e.g.
@Input() element;

Now, we can have the markup of the parent compoent, assign values to this "element" property, using the normal property binding syntax, i.e. [element]="Hi There". The markup of the same component can access the values directly.

The @Input() decorator can be configured to use a different value outside the component.
e.g.
@Input('srvElement') element;

Now, the parent markup which assigns this value would need to use the syntax [srvElement]="Hi There". The previous [element]="Hi There" code will not work.

____________________________________________________
Raising events from a component, to its parent
____________________________________________________ 
We raise events from a component using the EventEmitter<> construct provided by Angular, also paring it with an @Output() decorator.
e.g. if we need to raise an event like objectAdded from our component, and the data passed is an object of type {name:string, content:string}, we need to declare this like
@Output() objectAdded = new EventEmitter<{name:string, content:string}>();

now, whenever we want to emit the event, we would write

objectAdded.emit({name:"Object Name", content: "Object Content"})

Now, the parent component would need to catch the event using code like below
e.g.
<app-child (objectAdded)="onObjectAdded()"></app-child>

Similar to the @Input decorator, we can pass a parameter to the @Output() decorator to change the name of the object passed from the outside
e.g. if in the above example, we want the parent to use the 'objAdded' event instead of the 'objectAdded' event, we can define the @Output() decorator like
@Output('objAdded') objectAdded = new EventEmitter<{.......
_________________________________________________________

Local Reference
_______________________________________________________

We can lable an HTML element in the markup using a local reference like below
<input type="text" #inputServerName>

The HTML element has now been identified as "inputServerName". This element can then be passed into Angular functions as a parameter, and properties can be extracted from these. 

e.g. <app-server (click)="onButtonClick(inputServerName)"></app-server>
These can even be used in the function like below
onButtonClick(inputFromComponent: HTMLInputElement)
{
    this.local_value = inputServerName.value;
}

The local reference is not visible in the .ts file
_____________________________________
@ViewChild
_____________________________________

Just like we can get a markup element using the Local Reference, we can also bind the Local Reference to a Component property using the @ViewChild() decorator.
e.g. 
Add a Local Reference like this
<input type="text" #inputServerName>

And in the .ts file, we can declare a property like this
@ViewChild('inputServerName') inputName:ElementRef;

Now, anywhere in the code, we can access values of the input element on which we have a local reference lik
local_value = this.inputName.nativeElement.value;

We can also use this to change the value of the element in the markup, i.e. modify the DOM, 
e.g. this.inputName.nativeElement.value = "NewName"
However, we should not do so as angular has a "correct" way of doing this.

___________________________________
ng-content
___________________________________
This is a directive which allows the parent element to pass across HTML content to the child element.

Normally, anything between a child element's selectors is lost on rendering
e.g.
<app-child>My Child </app-child>

will render without the "My Child".

However, the child element can choose to output the HTML entered between it's selectors by the parent, by using the code
<ng-content></ng-content>. 
This will simply project the HTML passed from the parent to where the child's markup contains the above code.

Also, the child compoent can access any HTML element in the .ts file, if that is marked as a Local Reference with a #<identifier>
e.g.
In the parent component markup, in the content which will be projected to the child, we can set
<p #projectedParagraph>
...content which is projected
</p>

and in the child ts, we can access the HTML using
@ContentChild('projectedParagraph') contentFromParent:ElementRef

and then contentFromParent.nativeElement.<value to access>


